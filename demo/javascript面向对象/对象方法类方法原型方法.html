<!DOCTYPE>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	</head>
	<script type="text/javascript" src="../jquery-2.1.1.min.js"></script>
	<body>
		<h2>
		hl ht hd
		</h2>
		<div>
			<hl>
			<ht>
			zhelishibiaoti
			</ht>
			<hd>
			neirong
			</hd>
			</hl>
			<h2>
			div
			</h2>
			<div>
				<div>
					zhelishibiaoti
				</div>
				<div>
					neirong
				</div>
			</div>
		</div>
	</body>
	<script type="text/javascript">
	var student;
		function People(name)
	{
		this.name=name;
		//对象方法
		this.Introduce=function(){
			alert("People.Introduce()");
		}
		this.Introduce2=function(){
			alert("People.Introduce2()");
			return 1;
		}
		this.OutMethod=function(){
			alert("People.OutMethod()");
		}
	}
	function Student(name)
	{
		this.name=name;
		//对象方法
		this.Introduce=function(){
			alert("Student.Introduce()");
		}
		this.Introduce2=function(){
			alert("Student.Introduce2()");
			return 1;
		}
		this.IntroduceChinese=function(){
			alert("Student2.IntroduceChinese()");
		}
	}

	//类方法 静态
	Student.Run1=function(){
		alert("I can run");
	}
		Student.IntroduceChinese=function(){
			alert("我是外部类方法");
		}
	//原型方法				
		Student.prototype.OutMethod=function(){
			alert("我是外部原型方法OutMethod:我不会覆盖内部的同名字方法"+
			"这里要说明的是：使用字面量方式创建后，不能再使用字面量的方式重写原型，一旦重写了原型，原来的原型中定义的所有属性和方法都将被清除。如下： ");
		}
	$(function(){
		 student=new Student("Windking");
		 student.OutMethod();

		Student.prototype=new People();
		//相当于Student中有一个变量prototype这个变量用来扩展Student类
		//设计模式:合成复用原则(尽量减少继承,通过用组合代替继承)
		//运用的是一种聚合/组合关系
		student=new Student("Windking2");
		student.OutMethod();

		student.Introduce2();
		//在"继承"中,因为子类会覆盖父类的同名方法
		//这里也一样,在方法调用时会根据就近原则来调用.
		//优先级是:实例属性>对象属性>原型属性。这就是采用了就近原则：调用时首先查找实例中是否直接定义了这个属性，有则返回实例属性；如果实例属性中没有就去构造函数中查找，有则返回；如果前面两者都没有就去原型对象中查找，如果没有则返回undefined。

		//如果想让该对象调用父类的方法则采用下面的方法
		var people=new People();
		people.Introduce2.call(student);

		// 		这里的people.Introduce2.call(student);阅读为“将student当做people来调用，调用它的对象方法Introduce2”

		// 好了，这里可能有人会问，为什么不用People.showMsg.call(instance);

		// 这就是对象方法和类方法的区别，我们想调用的是baseClass的对象方法
	});

	</script>
</html>